<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Watchtower Live</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîπ</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
      background: linear-gradient(45deg, #00ff88, #00ccff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-size: 2.5rem;
      font-weight: 700;
    }

    .video-container {
      position: relative;
      display: inline-block;
      margin: 0 auto;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0, 255, 136, 0.1);
      background: #000;
      max-height: 480px;
    }

    #video {
      display: block;
      max-width: 100%;
      height: auto;
      border-radius: 15px;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      border-radius: 15px;
    }

    .main-content {
      display: flex;
      gap: 30px;
      margin-top: 30px;
    }

    .video-section {
      flex: 1;
      text-align: center;
      height: 600px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }



    .controls-section {
      flex: 0 0 300px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      height: 540px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .controls-section::-webkit-scrollbar {
      width: 6px;
    }

    .controls-section::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    .controls-section::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 136, 0.3);
      border-radius: 3px;
    }

    .controls-section::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 136, 0.5);
    }

    .gallery-section {
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      /* margin-top: 30px; */
    }

    .splide {
      margin-top: 20px;
    }

    .splide__slide {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .splide__slide img {
      max-width: 100%;
      max-height: 400px;
      border-radius: 10px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }

    .splide__arrow {
      background: rgba(0, 255, 136, 0.2);
      border: 1px solid rgba(0, 255, 136, 0.3);
    }

    .splide__arrow:hover {
      background: rgba(0, 255, 136, 0.3);
    }

    .splide__pagination__page {
      background: rgba(255, 255, 255, 0.3);
    }

    .splide__pagination__page.is-active {
      background: #00ff88;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(45deg, #00ff88, #00ccff);
      color: #000;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
    }

    button.danger {
      background: linear-gradient(45deg, #ff4757, #ff6b7a);
      color: white;
    }

    button.danger:hover {
      box-shadow: 0 10px 20px rgba(255, 71, 87, 0.3);
    }

    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid rgba(0, 255, 136, 0.3);
      font-size: 14px;
    }

    .gallery {
      max-height: 500px;
      overflow-y: auto;
      margin-top: 20px;
    }

    .gallery h3 {
      margin-bottom: 15px;
      color: #00ff88;
    }

    .gallery-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      margin-bottom: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      transition: background 0.3s ease;
    }

    .gallery-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .gallery-item img {
      width: 60px;
      height: 45px;
      object-fit: cover;
      border-radius: 4px;
      margin-right: 10px;
    }

    .gallery-item span {
      flex: 1;
      font-size: 12px;
      color: #ccc;
    }

    .delete-btn {
      background: #ff4757;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .delete-btn:hover {
      background: #ff3742;
    }

    .settings {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .settings h4 {
      color: #00ccff;
      margin-bottom: 15px;
      text-align: center;
    }

    .setting-group {
      margin-bottom: 20px;
    }

    .setting-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #ccc;
    }

    .setting-group h5 {
      color: #00ff88;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .setting-group input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }

    .setting-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(45deg, #00ff88, #00ccff);
      cursor: pointer;
    }

    .setting-group input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(45deg, #00ff88, #00ccff);
      cursor: pointer;
      border: none;
    }

    .checkbox-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 13px;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .checkbox-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .checkbox-item input[type="checkbox"] {
      margin-right: 6px;
      accent-color: #00ff88;
    }

    .settings-btn {
      width: 100%;
      margin: 5px 0;
      padding: 8px 12px;
      font-size: 12px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.1);
      color: #ccc;
      transition: all 0.3s ease;
    }

    .settings-btn.primary {
      background: linear-gradient(45deg, #00ff88, #00ccff);
      color: #000;
      font-weight: 600;
    }

    .settings-btn:hover {
      transform: translateY(-1px);
    }

    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 20px;
    }

    .stats h4 {
      color: #00ccff;
      margin-bottom: 10px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .controls {
        flex-direction: column;
        align-items: center;
      }

      button {
        width: 200px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üëÄ Watchtower Live</h1>

    <div class="main-content">
      <div class="video-section">
        <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="overlay"></canvas>
        </div>

        <div id="status" class="status">
          Initializing camera and detection model...
        </div>
      </div>

      <div class="controls-section">
        <div class="controls">
          <button id="toggleBtn">Toggle Detection Boxes</button>
          <button id="recordToggleBtn">Toggle Recording</button>
          <button id="testNotificationBtn">Test Notification</button>
          <button id="clearAllBtn" class="danger">Clear All Images</button>
        </div>

        <div class="stats">
          <h4>Statistics</h4>
          <div class="stat-row">
            <span>Total Images:</span>
            <span id="totalImages">0</span>
          </div>
          <div class="stat-row">
            <span>Detection Status:</span>
            <span id="detectionStatus">Loading...</span>
          </div>
          <div class="stat-row">
            <span>Recording:</span>
            <span id="recordingStatus">ON</span>
          </div>
          <div class="stat-row">
            <span>Active Objects:</span>
            <span id="activeObjects">person</span>
          </div>
          <div class="stat-row">
            <span>Last Detection:</span>
            <span id="lastDetection">None</span>
          </div>
        </div>

        <div class="settings">
          <h4>Settings</h4>
          <div class="setting-group">
            <label>Confidence Threshold: <span id="confidenceValue">30%</span></label>
            <input type="range" id="confidenceSlider" min="10" max="90" value="30">
          </div>
          <div class="setting-group">
            <label>Save Interval: <span id="saveIntervalValue">3s</span></label>
            <input type="range" id="saveIntervalSlider" min="1" max="10" value="3">
          </div>
          <div class="setting-group">
            <label>Notification Interval: <span id="notificationIntervalValue">30s</span></label>
            <input type="range" id="notificationIntervalSlider" min="10" max="60" value="30">
          </div>
          <div class="setting-group">
            <label>Objects to Detect:</label>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-person" checked>
              <label for="detect-person">Person</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-car">
              <label for="detect-car">Car</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-dog">
              <label for="detect-dog">Dog</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-cat">
              <label for="detect-cat">Cat</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-cell phone">
              <label for="detect-cell phone">Cell Phone</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-laptop">
              <label for="detect-laptop">Laptop</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-bicycle">
              <label for="detect-bicycle">Bicycle</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-motorcycle">
              <label for="detect-motorcycle">Motorcycle</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-truck">
              <label for="detect-truck">Truck</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="detect-bus">
              <label for="detect-bus">Bus</label>
            </div>
          </div>
          <div class="setting-buttons">
            <button id="saveSettingsBtn" class="settings-btn primary">Save Settings</button>
            <button id="resetSettingsBtn" class="settings-btn">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <div class="gallery-section">
      <h4>Recorded Images</h4>
      <div class="splide" id="gallerySplide">
        <div class="splide__track">
          <ul class="splide__list" id="galleryList">
            <!-- Images will be loaded here -->
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/css/splide.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/js/splide.min.js"></script>
  <script>
    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");
    const status = document.getElementById("status");
    const ws = new WebSocket(`ws://${location.host}`);

    let showBoxes = true;
    let isRecording = true;
    let model = null;
    let lastSaveTime = 0;
    let lastNotificationTime = 0;
    let SAVE_THROTTLE = 3000; // Save image every 3 seconds max
    let NOTIFICATION_THROTTLE = 30000; // Notification every 30 seconds max
    let CONFIDENCE_THRESHOLD = 0.3; // Detection confidence threshold
    let DETECTED_OBJECTS = new Set(['person']); // Objects to detect
    // console.log('üéØ Initial detection objects:', Array.from(DETECTED_OBJECTS)); // Commented out to reduce logging
    let lastDetectionTime = null;

    // --- Status updates ---
    function updateStatus(message) {
      status.textContent = message;
    }

    window.updateStats = function () {
      const detectionStatus = document.getElementById('detectionStatus');
      const recordingStatus = document.getElementById('recordingStatus');
      const activeObjects = document.getElementById('activeObjects');
      const lastDetection = document.getElementById('lastDetection');

      if (detectionStatus) {
        detectionStatus.textContent = showBoxes ? 'ON' : 'OFF';
      }

      if (recordingStatus) {
        recordingStatus.textContent = isRecording ? 'ON' : 'OFF';
      }

      if (activeObjects) {
        const activeObjectsList = Array.from(DETECTED_OBJECTS).join(', ');
        activeObjects.textContent = activeObjectsList || 'None';
      }

      if (lastDetection && lastDetectionTime) {
        lastDetection.textContent = lastDetectionTime.toLocaleTimeString();
      }

      // Update total images count separately for better performance
      updateTotalImagesCount();
    }

    // Separate function to update total images count
    window.updateTotalImagesCount = async function () {
      try {
        const res = await fetch("/recordings.json");
        const files = await res.json();
        const totalImages = document.getElementById('totalImages');
        if (totalImages) {
          totalImages.textContent = files.length;
        }
      } catch (error) {
        console.error('‚ùå Error updating total images count:', error);
      }
    }

    // --- Webcam setup ---
    window.setupCamera = function () {
      return new Promise(async (resolve, reject) => {
        try {
          console.log('üìπ Setting up camera...');

          // Force enable camera APIs for Raspberry Pi
          console.log('üîß Checking camera APIs...');
          console.log('navigator.getUserMedia:', navigator.getUserMedia);
          console.log('navigator.webkitGetUserMedia:', navigator.webkitGetUserMedia);
          console.log('navigator.mozGetUserMedia:', navigator.mozGetUserMedia);
          console.log('navigator.mediaDevices:', navigator.mediaDevices);

          // Create mediaDevices if it doesn't exist
          if (!navigator.mediaDevices) {
            console.log('üîß Creating mediaDevices object...');
            navigator.mediaDevices = {};
          }

          // Force create getUserMedia function
          if (!navigator.mediaDevices.getUserMedia) {
            console.log('üîß Creating getUserMedia function...');

            // Try multiple approaches to get camera access
            if (navigator.getUserMedia) {
              console.log('‚úÖ Using navigator.getUserMedia');
              navigator.mediaDevices.getUserMedia = function (constraints) {
                return new Promise((resolve, reject) => {
                  navigator.getUserMedia(constraints, resolve, reject);
                });
              };
            } else if (navigator.webkitGetUserMedia) {
              console.log('‚úÖ Using navigator.webkitGetUserMedia');
              navigator.mediaDevices.getUserMedia = function (constraints) {
                return new Promise((resolve, reject) => {
                  navigator.webkitGetUserMedia(constraints, resolve, reject);
                });
              };
            } else if (navigator.mozGetUserMedia) {
              console.log('‚úÖ Using navigator.mozGetUserMedia');
              navigator.mediaDevices.getUserMedia = function (constraints) {
                return new Promise((resolve, reject) => {
                  navigator.mozGetUserMedia(constraints, resolve, reject);
                });
              };
            } else {
              // Last resort: try to create a mock getUserMedia that might work
              console.log('‚ö†Ô∏è No camera API found, trying to create mock getUserMedia...');

              // Try to access the camera through a different method
              if (typeof MediaStream !== 'undefined') {
                navigator.mediaDevices.getUserMedia = function (constraints) {
                  return new Promise((resolve, reject) => {
                    // Try to access video devices directly
                    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                      navigator.mediaDevices.enumerateDevices()
                        .then(devices => {
                          const videoDevices = devices.filter(device => device.kind === 'videoinput');
                          console.log('üìπ Found video devices:', videoDevices);
                          if (videoDevices.length > 0) {
                            // Try to create a stream with the first video device
                            const video = document.createElement('video');
                            video.autoplay = true;
                            video.muted = true;
                            video.playsInline = true;

                            // Try to set the video source
                            if (navigator.mediaDevices.getUserMedia) {
                              navigator.mediaDevices.getUserMedia(constraints)
                                .then(resolve)
                                .catch(reject);
                            } else {
                              reject(new Error('No camera access method available'));
                            }
                          } else {
                            reject(new Error('No video devices found'));
                          }
                        })
                        .catch(reject);
                    } else {
                      reject(new Error('No camera API available - try using Chromium browser with --use-fake-ui-for-media-stream flag'));
                    }
                  });
                };
              } else {
                throw new Error('No camera API available - try using Chromium browser with --use-fake-ui-for-media-stream flag');
              }
            }
          }

          // Also create enumerateDevices if it doesn't exist
          if (!navigator.mediaDevices.enumerateDevices) {
            navigator.mediaDevices.enumerateDevices = function () {
              return Promise.resolve([]);
            };
          }

          // Try to force detect video devices
          console.log('üìπ Available video devices: 0');
          if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
            navigator.mediaDevices.enumerateDevices()
              .then(devices => {
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                console.log('üìπ Found video devices:', videoDevices);
              })
              .catch(err => {
                console.log('‚ùå Error enumerating devices:', err);
              });
          }

          console.log('üìπ Media devices supported, requesting camera access...');

          // Try multiple video constraints for Raspberry Pi compatibility
          const videoConstraints = [
            // Pi-optimized resolutions
            { width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: 30 } },
            { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } },
            // Fallback constraints
            { width: { min: 320, ideal: 640, max: 1280 }, height: { min: 240, ideal: 480, max: 720 } },
            { video: true } // Most basic constraint
          ];

          let constraintIndex = 0;
          const tryNextConstraint = () => {
            if (constraintIndex >= videoConstraints.length) {
              throw new Error('All video constraints failed. Last error: No video devices found');
            }

            const constraint = videoConstraints[constraintIndex];
            console.log(`üìπ Trying video constraint ${constraintIndex + 1}...`);
            constraintIndex++;

            return navigator.mediaDevices.getUserMedia({ video: constraint })
              .catch(error => {
                console.log(`‚ùå Video constraint ${constraintIndex} failed:`, error.message);
                return tryNextConstraint();
              });
          };

          tryNextConstraint()
            .then(stream => {
              console.log('üìπ Video stream set, playing video...');
              video.srcObject = stream;
              video.play()
                .then(() => {
                  console.log('üìπ Video playing successfully');
                  // Set up canvas for detection overlay
                  const canvas = document.getElementById('overlay');
                  const ctx = canvas.getContext('2d');
                  canvas.width = video.videoWidth;
                  canvas.height = video.videoHeight;
                  console.log('üìπ Canvas setup:', canvas.width + 'x' + canvas.height);

                  // Wait for video metadata to load
                  // Set up canvas overlay when video is ready
                  const setupOverlay = () => {
                    if (!overlay || !video) return;

                    overlay.width = video.videoWidth;
                    overlay.height = video.videoHeight;
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    console.log(`üìπ Canvas setup: ${video.videoWidth}x${video.videoHeight}`);
                  };

                  video.addEventListener('loadedmetadata', setupOverlay);
                  video.addEventListener('resize', setupOverlay);

                  // Also setup after a short delay to ensure video dimensions are stable
                  setTimeout(setupOverlay, 500);

                  console.log('üìπ Camera setup complete!');
                  updateStatus("Camera ready!");
                  resolve();
                })
                .catch(err => {
                  console.error('‚ùå Video play failed:', err);
                  reject(err);
                });
            })
            .catch(err => {
              console.error('Camera error:', err);
              reject(err);
            });
        } catch (err) {
          updateStatus(`Camera error: ${err.message}`);
          console.error("Camera error:", err);
          reject(err);
        }
      });
    };

    // Show a placeholder or error message in the video area
    if (video) {
      video.style.display = 'none';
      const videoContainer = video.parentElement;
      if (videoContainer) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
              display: flex;
              align-items: center;
              justify-content: center;
              height: 400px;
              background: #2a2a2a;
              border-radius: 15px;
              color: #ff6b6b;
              font-size: 18px;
              text-align: center;
              padding: 20px;
            `;
        errorDiv.innerHTML = `
              <div>
                <div style="font-size: 48px; margin-bottom: 10px;">üìπ</div>
                <div>Camera not available</div>
                <div style="font-size: 14px; margin-top: 10px; color: #888;">
                  <strong>üçì Raspberry Pi Users:</strong><br>
                  1. Try advanced browser: <code>./pi-camera-browser.sh</code><br>
                  2. Or manual launch: <code>chromium-browser --use-fake-ui-for-media-stream --no-sandbox http://10.10.10.85:3000</code><br>
                  3. Check webcam: <code>fswebcam --no-banner --device /dev/video0 test.jpg</code>
                </div>
                <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #00ff88; color: #000; border: none; border-radius: 5px; cursor: pointer;">
                  üîÑ Retry Camera Access
                </button>
                <button onclick="testCameraAccess()" style="margin-top: 10px; padding: 10px 20px; background: #00ccff; color: #000; border: none; border-radius: 5px; cursor: pointer;">
                  üß™ Test Camera API
                </button>
              </div>
            `;
        videoContainer.appendChild(errorDiv);
      }
    }
      }
    }

    // --- Button event handlers ---
    const toggleBtn = document.getElementById("toggleBtn");
    if (toggleBtn) {
      toggleBtn.addEventListener("click", async () => {
        try {
          const res = await fetch("/toggle-boxes");
          const data = await res.json();
          showBoxes = data.showBoxes;
          console.log('üîò Detection boxes toggled to:', showBoxes ? 'ON' : 'OFF');
          updateStatus(`Detection boxes ${showBoxes ? 'enabled' : 'disabled'}`);
          updateStats();
        } catch (err) {
          updateStatus("Error toggling detection boxes");
        }
      });
    }

    const recordToggleBtn = document.getElementById("recordToggleBtn");
    if (recordToggleBtn) {
      recordToggleBtn.addEventListener("click", () => {
        isRecording = !isRecording;
        updateStatus(`Recording ${isRecording ? 'enabled' : 'disabled'}`);
        updateStats();
      });
    }

    const testNotificationBtn = document.getElementById("testNotificationBtn");
    if (testNotificationBtn) {
      testNotificationBtn.addEventListener("click", async () => {
        try {
          console.log('üß™ Test notification button clicked');
          updateStatus("Sending test notification...");

          const res = await fetch("/test-notification", { method: "POST" });
          const data = await res.json();

          if (res.ok) {
            updateStatus("‚úÖ Test notification sent successfully!");
            console.log('‚úÖ Test notification response:', data);
          } else {
            updateStatus(`‚ùå Test notification failed: ${data.error || 'Unknown error'}`);
            console.error('‚ùå Test notification error:', data);
          }
        } catch (err) {
          updateStatus("‚ùå Error sending test notification");
          console.error('‚ùå Test notification error:', err);
        }
      });
    }

    const clearAllBtn = document.getElementById("clearAllBtn");
    if (clearAllBtn) {
      clearAllBtn.addEventListener("click", async () => {
        if (confirm("Are you sure you want to delete all captured images?")) {
          try {
            const res = await fetch("/clear-all", { method: "POST" });
            if (res.ok) {
              updateStatus("All images deleted successfully");
              loadGallery();
            } else {
              updateStatus("Error deleting images");
            }
          } catch (err) {
            updateStatus("Error deleting images");
          }
        }
      });
    }

    // --- TensorFlow person detection ---
    window.loadModel = async function () {
      try {
        console.log('ü§ñ Starting to load AI detection model...');
        console.log('ü§ñ cocoSsd available:', typeof cocoSsd);
        console.log('ü§ñ tf available:', typeof tf);

        if (typeof cocoSsd === 'undefined') {
          throw new Error('cocoSsd is not available - TensorFlow.js may not be loaded');
        }

        updateStatus("Loading AI detection model...");
        model = await cocoSsd.load({ base: "lite_mobilenet_v2" });
        console.log('‚úÖ AI model loaded successfully!', model);
        updateStatus("AI model loaded successfully!");
      } catch (err) {
        console.error("‚ùå Model loading error:", err);
        updateStatus("Error loading AI model");
      }
    };

    function drawBoxes(predictions) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (!showBoxes) {
        return;
      }

      // Only log drawing if we have predictions and haven't logged recently
      if (predictions.length > 0 && (!window.lastDrawLog || Date.now() - window.lastDrawLog > 10000)) {
        console.log('üîò Drawing detection boxes for', predictions.length, 'predictions');
        window.lastDrawLog = Date.now();
      }

      // Scale factors to match video display size to actual video size
      const scaleX = overlay.width / video.videoWidth;
      const scaleY = overlay.height / video.videoHeight;

      ctx.lineWidth = 3;
      ctx.font = "16px sans-serif";
      ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
      ctx.shadowBlur = 4;

      predictions.forEach(prediction => {
        if (DETECTED_OBJECTS.has(prediction.class) && prediction.score > CONFIDENCE_THRESHOLD) {
          const [x, y, w, h] = prediction.bbox;

          // Apply scaling to match the displayed video size
          const scaledX = x * scaleX;
          const scaledY = y * scaleY;
          const scaledW = w * scaleX;
          const scaledH = h * scaleY;

          // Color coding for different objects
          const colors = {
            'person': '#00ff88',
            'car': '#ff6b7a',
            'bicycle': '#4ecdc4',
            'motorcycle': '#45b7d1',
            'truck': '#f39c12',
            'bus': '#9b59b6',
            'cat': '#e17055',
            'dog': '#74b9ff',
            'cell phone': '#fd79a8',
            'laptop': '#6c5ce7'
          };

          const color = colors[prediction.class] || '#00ff88';
          ctx.strokeStyle = color;
          ctx.fillStyle = color;

          // Draw detection box
          ctx.strokeRect(scaledX, scaledY, scaledW, scaledH);

          // Draw label background
          const label = `${prediction.class} ${(prediction.score * 100).toFixed(0)}%`;
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(scaledX, scaledY - 25, textWidth + 8, 20);

          // Draw label text
          ctx.fillStyle = "#000";
          ctx.fillText(label, scaledX + 4, scaledY - 8);
          ctx.fillStyle = color;
        }
      });

      ctx.shadowBlur = 0; // Reset shadow
    }

    // --- Main detection loop ---
    window.detectAndProcess = async function () {
      // Add a counter to track how many times this runs
      if (!window.detectionCounter) window.detectionCounter = 0;
      window.detectionCounter++;

      // Only log every 600 frames (about every 20 seconds) to reduce console spam
      if (window.detectionCounter % 600 === 0) {
        console.log('üîÑ Detection loop running, counter:', window.detectionCounter);
      }

      if (!model) {
        console.log('ü§ñ Model not loaded yet, retrying...');
        return requestAnimationFrame(detectAndProcess);
      }

      if (!video.videoWidth) {
        console.log('üìπ Video not ready yet, retrying...');
        return requestAnimationFrame(detectAndProcess);
      }

      let predictions = []; // Declare predictions variable at function scope

      try {
        predictions = await model.detect(video);

        // Only log detection results if objects are detected and we haven't logged recently
        if (predictions.length > 0 && (!window.lastDetectionLog || Date.now() - window.lastDetectionLog > 5000)) {
          console.log('üîç Detection results:', predictions.length, 'objects detected');

          // Log detected objects for debugging
          predictions.forEach(p => {
            if (DETECTED_OBJECTS.has(p.class)) {
              console.log(`üéØ Detected ${p.class} with confidence ${(p.score * 100).toFixed(1)}%`);
            }
          });

          window.lastDetectionLog = Date.now();
        }

        drawBoxes(predictions);

        // Check if any monitored object is detected and throttle saving/notifications
        const detectedObjects = predictions.filter(p =>
          DETECTED_OBJECTS.has(p.class) && p.score > CONFIDENCE_THRESHOLD
        );

        const objectDetected = detectedObjects.length > 0;
        const now = Date.now();

        if (objectDetected && isRecording) {
          lastDetectionTime = new Date();
          updateStats();

          // Throttled image saving
          if (now - lastSaveTime > SAVE_THROTTLE) {
            const canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const tempCtx = canvas.getContext("2d");
            tempCtx.drawImage(video, 0, 0);

            const detectedObjectNames = detectedObjects.map(p => p.class).join(', ');

            ws.send(JSON.stringify({
              imageData: canvas.toDataURL("image/jpeg", 0.8),
              objectDetected: true,
              detectedObjects: detectedObjectNames
            }));

            lastSaveTime = now;

            // Update total images count after saving
            setTimeout(() => updateTotalImagesCount(), 500);
          }

          // Throttled notifications
          if (now - lastNotificationTime > NOTIFICATION_THROTTLE) {
            const detectedObjectNames = detectedObjects.map(p => p.class).join(', ');
            fetch("/object-detected", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ objects: detectedObjectNames })
            }).catch(console.error);
            lastNotificationTime = now;
          }
        }
      } catch (err) {
        console.error("Detection error:", err);
      }

      // Add a small delay when no objects are detected to reduce CPU usage
      const delay = predictions.length === 0 ? 50 : 0;
      setTimeout(() => requestAnimationFrame(detectAndProcess), delay);

      // Periodically update total images count (every 30 seconds)
      const now = Date.now();
      if (!window.lastTotalUpdate || now - window.lastTotalUpdate > 30000) {
        updateTotalImagesCount();
        window.lastTotalUpdate = now;
      }
    }

    // --- Gallery management ---
    window.loadGallery = async function () {
      try {
        const res = await fetch("/recordings.json");
        const files = await res.json();
        const galleryList = document.getElementById("galleryList");

        // Update total count using the dedicated function
        updateTotalImagesCount();

        if (!galleryList) {
          console.error("Gallery list element not found");
          return;
        }

        if (files.length === 0) {
          galleryList.innerHTML = '<li class="splide__slide"><div style="text-align: center; color: #666; padding: 40px;">No captures yet</div></li>';
          return;
        }

        // Create Splide slides
        galleryList.innerHTML = files.slice(0, 20).map(file => `
            <li class="splide__slide">
              <div style="position: relative; display: inline-block;">
                <img src="/recordings/${file}" alt="Capture" onclick="window.open('/recordings/${file}', '_blank')" style="cursor: pointer;">
                <div style="position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px;">
                  ${new Date(parseInt(file.split('-')[1].split('.')[0])).toLocaleString()}
                </div>
                <button class="delete-btn" onclick="deleteImage('${file}')" style="position: absolute; top: 10px; right: 10px;">Delete</button>
              </div>
            </li>
          `).join('');

        // Initialize Splide if available
        if (typeof Splide !== 'undefined') {
          try {
            // Remove existing Splide instance if it exists
            const existingSplide = document.querySelector('.splide--initialized');
            if (existingSplide) {
              existingSplide.remove();
            }

            window.gallerySplide = new Splide('#gallerySplide', {
              type: 'loop',
              perPage: 3,
              perMove: 1,
              gap: '1rem',
              pagination: false,
              arrows: true,
              autoplay: false,
              breakpoints: {
                768: {
                  perPage: 2,
                },
                480: {
                  perPage: 1,
                }
              }
            });

            window.gallerySplide.mount();
          } catch (error) {
            console.error('‚ùå Error initializing Splide:', error);
          }
        } else {
          console.warn('‚ö†Ô∏è Splide.js not available, using basic gallery');
          // Fallback to basic gallery display
          const galleryList = document.getElementById("galleryList");
          if (galleryList) {
            galleryList.innerHTML = files.slice(0, 20).map(file => `
                <li style="display: inline-block; margin: 10px; vertical-align: top;">
                  <div style="position: relative; display: inline-block;">
                    <img src="/recordings/${file}" alt="Capture" onclick="window.open('/recordings/${file}', '_blank')" style="cursor: pointer; max-width: 200px; max-height: 150px; border-radius: 5px;">
                    <div style="position: absolute; bottom: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 3px 6px; border-radius: 3px; font-size: 10px;">
                      ${new Date(parseInt(file.split('-')[1].split('.')[0])).toLocaleString()}
                    </div>
                    <button class="delete-btn" onclick="deleteImage('${file}')" style="position: absolute; top: 5px; right: 5px; font-size: 10px; padding: 2px 6px;">Delete</button>
                  </div>
                </li>
              `).join('');
          }
        }
      } catch (err) {
        console.error("Gallery loading error:", err);
        const galleryList = document.getElementById("galleryList");
        if (galleryList) {
          galleryList.innerHTML = '<li class="splide__slide"><div style="color: #ff4757; padding: 40px;">Error loading gallery</div></li>';
        }
      }
    }

    // --- Settings Management ---
    window.loadSettings = function () {
      // Load settings from localStorage
      let settings;
      try {
        const savedSettings = localStorage.getItem('watchtowerSettings');
        settings = savedSettings ? JSON.parse(savedSettings) : {
          confidence: 30,
          saveInterval: 3,
          notificationInterval: 30,
          detectedObjects: ['person']
        };
      } catch (error) {
        console.warn('Error loading settings from localStorage, using defaults:', error);
        settings = {
          confidence: 30,
          saveInterval: 3,
          notificationInterval: 30,
          detectedObjects: ['person']
        };
      }

      CONFIDENCE_THRESHOLD = settings.confidence / 100;
      SAVE_THROTTLE = settings.saveInterval * 1000;
      NOTIFICATION_THROTTLE = settings.notificationInterval * 1000;
      DETECTED_OBJECTS = new Set(settings.detectedObjects);

      // Update UI elements (with null checks)
      const confidenceSlider = document.getElementById('confidenceSlider');
      const confidenceValue = document.getElementById('confidenceValue');
      if (confidenceSlider) confidenceSlider.value = settings.confidence;
      if (confidenceValue) confidenceValue.textContent = settings.confidence + '%';

      const saveIntervalSlider = document.getElementById('saveIntervalSlider');
      const saveIntervalValue = document.getElementById('saveIntervalValue');
      if (saveIntervalSlider) saveIntervalSlider.value = settings.saveInterval;
      if (saveIntervalValue) saveIntervalValue.textContent = settings.saveInterval + 's';

      const notificationIntervalSlider = document.getElementById('notificationIntervalSlider');
      const notificationIntervalValue = document.getElementById('notificationIntervalValue');
      if (notificationIntervalSlider) notificationIntervalSlider.value = settings.notificationInterval;
      if (notificationIntervalValue) notificationIntervalValue.textContent = settings.notificationInterval + 's';

      // Update checkboxes
      const checkboxes = document.querySelectorAll('.checkbox-item input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        const objectName = checkbox.id.replace('detect-', '');
        checkbox.checked = DETECTED_OBJECTS.has(objectName);
      });

      // Don't call updateStats during initialization to avoid circular dependencies
      // updateStats will be called later in the init function
    }

    window.saveSettings = function (showMessage = true) {
      const confidenceSlider = document.getElementById('confidenceSlider');
      const saveIntervalSlider = document.getElementById('saveIntervalSlider');
      const notificationIntervalSlider = document.getElementById('notificationIntervalSlider');

      const settings = {
        confidence: confidenceSlider ? parseInt(confidenceSlider.value) : 30,
        saveInterval: saveIntervalSlider ? parseInt(saveIntervalSlider.value) : 3,
        notificationInterval: notificationIntervalSlider ? parseInt(notificationIntervalSlider.value) : 30,
        detectedObjects: Array.from(DETECTED_OBJECTS)
      };

      // Save to localStorage
      try {
        localStorage.setItem('watchtowerSettings', JSON.stringify(settings));
        console.log('üíæ Settings saved to localStorage:', settings);
      } catch (error) {
        console.error('‚ùå Error saving settings to localStorage:', error);
        // Fallback to in-memory storage
        window.watchtowerSettings = settings;
      }

      if (showMessage) {
        updateStatus('Settings saved successfully!');
        setTimeout(() => updateStatus('AI model loaded successfully!'), 2000);
      }
    }

    window.resetSettings = function () {
      if (confirm('Reset all settings to defaults?')) {
        // Clear localStorage
        try {
          localStorage.removeItem('watchtowerSettings');
          console.log('üóëÔ∏è Settings cleared from localStorage');
        } catch (error) {
          console.error('‚ùå Error clearing settings from localStorage:', error);
        }

        // Clear in-memory storage
        delete window.watchtowerSettings;

        // Reload settings (will use defaults)
        loadSettings();
        updateStatus('Settings reset to defaults');
      }
    }

    // Settings event handlers
    window.setupSettings = function () {
      // Sliders
      const confidenceSlider = document.getElementById('confidenceSlider');
      if (confidenceSlider) {
        confidenceSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          const confidenceValue = document.getElementById('confidenceValue');
          if (confidenceValue) confidenceValue.textContent = value + '%';
          CONFIDENCE_THRESHOLD = value / 100;
          // Auto-save settings when slider changes
          saveSettings(false);
        });
      }

      const saveIntervalSlider = document.getElementById('saveIntervalSlider');
      if (saveIntervalSlider) {
        saveIntervalSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          const saveIntervalValue = document.getElementById('saveIntervalValue');
          if (saveIntervalValue) saveIntervalValue.textContent = value + 's';
          SAVE_THROTTLE = value * 1000;
          // Auto-save settings when slider changes
          saveSettings(false);
        });
      }

      const notificationIntervalSlider = document.getElementById('notificationIntervalSlider');
      if (notificationIntervalSlider) {
        notificationIntervalSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          const notificationIntervalValue = document.getElementById('notificationIntervalValue');
          if (notificationIntervalValue) notificationIntervalValue.textContent = value + 's';
          NOTIFICATION_THROTTLE = value * 1000;
          // Auto-save settings when slider changes
          saveSettings(false);
        });
      }

      // Checkboxes
      const checkboxes = document.querySelectorAll('.checkbox-item input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const objectName = e.target.id.replace('detect-', '');
          if (e.target.checked) {
            DETECTED_OBJECTS.add(objectName);
            console.log(`üéØ Added ${objectName} to detection list`);
          } else {
            DETECTED_OBJECTS.delete(objectName);
            console.log(`üéØ Removed ${objectName} from detection list`);
          }
          updateStats();
          // Auto-save settings when checkboxes change
          saveSettings(false);
        });
      });

      // Buttons
      const saveSettingsBtn = document.getElementById('saveSettingsBtn');
      if (saveSettingsBtn) {
        saveSettingsBtn.addEventListener('click', saveSettings);
      }

      const resetSettingsBtn = document.getElementById('resetSettingsBtn');
      if (resetSettingsBtn) {
        resetSettingsBtn.addEventListener('click', resetSettings);
      }
    }
    window.deleteImage = async function (filename) {
      if (confirm(`Delete ${filename}?`)) {
        try {
          const res = await fetch(`/delete-image/${filename}`, { method: "DELETE" });
          if (res.ok) {
            loadGallery();
            updateTotalImagesCount(); // Update count immediately after deletion
            updateStatus(`Deleted ${filename}`);
          } else {
            updateStatus(`Error deleting ${filename}`);
          }
        } catch (err) {
          updateStatus(`Error deleting ${filename}`);
        }
      }
    };

    // Test camera access function
    window.testCameraAccess = function () {
      console.log('üß™ Testing camera access...');
      console.log('navigator.mediaDevices:', navigator.mediaDevices);
      console.log('navigator.getUserMedia:', navigator.getUserMedia);
      console.log('navigator.webkitGetUserMedia:', navigator.webkitGetUserMedia);
      console.log('navigator.mozGetUserMedia:', navigator.mozGetUserMedia);

      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        console.log('‚úÖ MediaDevices API available');
        navigator.mediaDevices.getUserMedia({ video: true })
          .then(stream => {
            console.log('‚úÖ Camera access successful!', stream);
            alert('‚úÖ Camera access successful! Check console for details.');
          })
          .catch(err => {
            console.error('‚ùå Camera access failed:', err);
            alert('‚ùå Camera access failed: ' + err.message);
          });
      } else {
        console.log('‚ùå MediaDevices API not available');
        alert('‚ùå MediaDevices API not available. Try the advanced browser launch script.');
      }
    }

    // --- Helper function for VAPID key conversion ---
    function urlBase64ToUint8Array(base64String) {
      if (!base64String || base64String === 'VAPID_PUBLIC_KEY_PLACEHOLDER') {
        console.warn('VAPID public key not configured');
        return null;
      }

      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = atob(base64);
      return Uint8Array.from([...rawData].map(c => c.charCodeAt(0)));
    }

    // --- Push notifications ---
    window.setupNotifications = async function () {
      if (!('serviceWorker' in navigator)) {
        updateStatus("Service Workers not supported");
        return;
      }

      if (!('PushManager' in window)) {
        updateStatus("Push messaging not supported");
        return;
      }

      try {
        console.log('üîß Registering service worker...');
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('‚úÖ Service Worker registered:', registration);

        // Wait for service worker to be ready
        await navigator.serviceWorker.ready;
        console.log('‚úÖ Service Worker ready');

        // Check current notification permission
        let permission = Notification.permission;
        console.log('üîî Current notification permission:', permission);

        if (permission === 'default') {
          console.log('üì± Requesting notification permission...');
          permission = await Notification.requestPermission();
          console.log('üì± Permission result:', permission);
        }

        if (permission === 'granted') {
          console.log('üîë Getting VAPID key from server...');
          const vapidResponse = await fetch('/vapid-public-key');
          const { publicKey } = await vapidResponse.json();

          if (!publicKey) {
            updateStatus("‚ùå VAPID keys not configured on server");
            return;
          }

          console.log('üîë VAPID key received, length:', publicKey.length);

          const applicationServerKey = urlBase64ToUint8Array(publicKey);
          if (!applicationServerKey) {
            updateStatus("‚ùå Invalid VAPID public key format");
            return;
          }

          console.log('üì± Subscribing to push notifications...');

          // Check if already subscribed
          let subscription = await registration.pushManager.getSubscription();

          if (!subscription) {
            // Subscribe to push notifications
            subscription = await registration.pushManager.subscribe({
              userVisibleOnly: true,
              applicationServerKey: applicationServerKey
            });
            console.log('‚úÖ New subscription created');
          } else {
            console.log('‚úÖ Using existing subscription');
          }

          console.log('üì§ Sending subscription to server...');

          // Send subscription to server
          const response = await fetch('/subscribe', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(subscription)
          });

          if (response.ok) {
            const result = await response.json();
            updateStatus("‚úÖ Notifications enabled successfully!");
            console.log('‚úÖ Subscription sent to server:', result);
          } else {
            const error = await response.text();
            updateStatus("‚ùå Failed to register subscription");
            console.error('‚ùå Server error:', error);
            console.error('‚ùå Response status:', response.status);
          }

        } else if (permission === 'denied') {
          updateStatus("‚ùå Notifications permission denied");
          console.log('‚ùå User denied notification permission');
        } else {
          updateStatus("‚ùå Notifications permission not granted");
          console.log('‚ùå Notification permission state:', permission);
        }
      } catch (err) {
        console.error("‚ùå Notification setup failed:", err);
        updateStatus(`‚ùå Notification error: ${err.message}`);
      }
    }
    }

    // --- WebSocket handling ---
    ws.onopen = () => {
      console.log('üîó WebSocket connected to server');
      updateStatus("Connected to server");
    };

    ws.onmessage = (event) => {
      console.log('üì® WebSocket message received:', event.data);
      const data = JSON.parse(event.data);
      if (data.newSnapshot) {
        console.log('üñºÔ∏è New snapshot received, refreshing gallery...');
        loadGallery(); // Refresh gallery when new image is saved
      }
    };

    ws.onclose = () => {
      console.log('üîå WebSocket disconnected from server');
      updateStatus("Disconnected from server - trying to reconnect...");
      setTimeout(() => location.reload(), 3000);
    };

    // --- Initialize everything ---
    window.init = async function () {
      try {
        console.log('üöÄ Initializing Watchtower Live...');

        // Check if required functions exist before calling them
        if (typeof setupSettings === 'function') {
          console.log('‚öôÔ∏è Setting up settings...');
          setupSettings();
        } else {
          console.error('‚ùå setupSettings function not found');
        }

        if (typeof loadSettings === 'function') {
          console.log('üìã Loading settings...');
          loadSettings();
        } else {
          console.error('‚ùå loadSettings function not found');
        }

        console.log('üìπ Setting up camera...');
        if (typeof setupCamera === 'function') {
          await setupCamera();
        } else {
          console.error('‚ùå setupCamera function not found');
        }

        console.log('ü§ñ Loading AI model...');
        if (typeof loadModel === 'function') {
          await loadModel();
        } else {
          console.error('‚ùå loadModel function not found');
        }

        console.log('üîî Setting up notifications...');
        if (typeof setupNotifications === 'function') {
          await setupNotifications();
        } else {
          console.error('‚ùå setupNotifications function not found');
        }

        console.log('üñºÔ∏è Loading gallery...');
        if (typeof loadGallery === 'function') {
          loadGallery();
        } else {
          console.error('‚ùå loadGallery function not found');
        }

        // Update stats after all functions are loaded
        if (typeof updateStats === 'function') {
          updateStats();
        } else {
          console.error('‚ùå updateStats function not found');
        }

        console.log('üîÑ Starting detection loop...');
        if (typeof detectAndProcess === 'function') {
          detectAndProcess();
        } else {
          console.error('‚ùå detectAndProcess function not found');
        }

        console.log('‚úÖ Initialization complete!');
      } catch (err) {
        console.error('‚ùå Initialization failed:', err);
        if (typeof updateStatus === 'function') {
          updateStatus(`Initialization error: ${err.message}`);
        }
      }
    }

    // Start initialization when page loads
    // Start initialization when page loads
    // Wait for all functions to be defined before initializing
    function startInitialization() {
      // Check if all required functions are defined
      const requiredFunctions = ['setupSettings', 'loadSettings', 'setupCamera', 'loadModel', 'setupNotifications', 'loadGallery', 'updateStats', 'updateTotalImagesCount', 'detectAndProcess'];
      const missingFunctions = requiredFunctions.filter(func => typeof window[func] !== 'function');

      if (missingFunctions.length > 0) {
        console.log('‚è≥ Waiting for functions to be defined:', missingFunctions);
        setTimeout(startInitialization, 50);
        return;
      }

      console.log('‚úÖ All functions are defined, starting initialization...');

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    }

    // Start the initialization process
    console.log('üîß Starting function availability check...');
    startInitialization();
  </script>
</body>

</html>